
/*********************************************************************************
	File: xline.gdl

	For testing cross-line contextualization.

	Compile with stddr.ttf

	To test, type something like these examples:
		abc$x
		abcx@
		abc$x@
	and force a line break after the x.
*********************************************************************************/

#include "stddef.gdh"

Bidi = false;

#define duplicated user1


table(glyph) {MUnits = 1000 }

	g_A = codepoint("A");
	g_B = codepoint("B");
	g_C = codepoint("C");
	g_D = codepoint("D");
	g_E = codepoint("E");
	g_F = codepoint("F");
	g_G = codepoint("G");

	g_a = codepoint("a");
	g_b = codepoint("b");
	g_c = codepoint("c");
	g_d = codepoint("d");
	g_e = codepoint("e");
	g_f = codepoint("f");
	g_g = codepoint("g");

	g_x = codepoint("x");
	g_y = codepoint("y");
	g_z = codepoint("z");

	g_asterisk = codepoint("*") { ptCenter = point(bb.width/2, bb.height/2) };
	g_dollar = codepoint("$") { xWid = aw };
	g_hash = codepoint("#");
	g_at = codepoint("@") { xWid = aw };
	g_amp = codepoint("&") {xWid = aw };
	g_percent = codepoint("%");

	g_leftArrow = codepoint("<") { xWid = aw };
	g_rightArrow = codepoint(">") { xWid = aw };

	clsUpper = codepoint("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
		{ ptCenter = point(bb.width/2, ascent/2) };
	clsLower = codepoint("abcdefghijklmnopqrstuvwxyz");

	clsMyAny = glyphid(2..216) { justify.stretch = 700m };

	g_m = codepoint("m");
	g_Mlig = codepoint("M") {
			component.one = box(0,0, bb.width/2, ascent);
			component.two = box(bb.width/2,0, bb.width,ascent) };
			
	gSpace = U+0020 { justify.stretch = 3000m };
	
	clsXYZ = (g_x g_y g_z);

endtable; // glyph


table(lb)

	// Allow non-optimal linebreaks after x, y, or z.
	clsXYZ {break = BREAK_INTRA};

endtable; // lb


table(sub)

pass(1)

	// Switch the $ and @ if they are both there, and insert & after the one on the first
	// line and before the one on the second line. Note that these rules supercede the rule
	// to insert the left- and right-arrows.
	g_dollar  _  _  g_at  >  @7  g_amp:7  g_amp:1  @1
		/  _  _  ANY?  # {break == BREAK_INTRA}  ANY?  _  _ ;
		
	g_dollar
		clsXYZ {measure.endofline = g_at.aw - g_dollar.aw + g_amp.aw}
		ANY {measure.startofline = g_dollar.aw - g_at.aw + g_amp.aw}
		g_at;
	g_dollar
		clsXYZ {measure.endofline = g_at.aw - g_dollar.aw + g_amp.aw}
		g_at {measure.startofline = g_dollar.aw - g_at.aw + g_amp.aw};


	// Just copy the $ to the following segment.
	g_dollar  _  >  @1 {duplicated = true}  g_dollar:1
		/ _ {duplicated == false}  ANY? ^ # {break == BREAK_INTRA}  ANY?  _ ;
		
	g_dollar
		clsXYZ {measure.endofline = g_rightArrow.aw}
		ANY {measure.startofline = g_dollar.aw + g_leftArrow.aw};


	// Just copy the @ to the previous segment.
	_  g_at  > g_at:5  @5 {duplicated = true}
		/  _  ANY? ^  # {break == BREAK_INTRA}  ANY?  _ {duplicated == false};
		
	clsXYZ {measure.endofline = g_at.aw + g_rightArrow.aw}
		ANY  {measure.startofline = g_leftArrow.aw}
		g_at;

	clsXYZ {measure.endofline = g_at.aw + g_rightArrow.aw}
		g_at  {measure.startofline = g_leftArrow.aw};


	// Insert a '<' at the beginning of the line and a '>' at the end.
	_ > g_leftArrow /  #  _;
	_ > g_rightArrow  /  clsMyAny  _  # ^ ;
	
	clsMyAny {measure {startofline = g_leftArrow.aw; endofline = g_rightArrow.aw}};
	
endpass;

pass(2)

	// Don't stretch trailing white space.
	gSpace {justify.stretch = 0} / _  [gSpace [gSpace [gSpace gSpace?]? ]? ]?  # ;
	// In fact, don't stretch any line-boundary glyph.
	clsMyAny {justify.stretch = 0} /  _  #;
	
	
endpass;

endtable; // sub


table(pos)

	clsMyAny {adv.x += justify.width};
	
endtable; // pos
